<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Süper Penaltı Pro</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Russo+One&display=swap');
        
        body {
            margin: 0;
            overflow: hidden;
            background-color: #2d3436;
            font-family: 'Russo One', sans-serif;
            touch-action: none; /* Mobilde kaydırmayı engelle */
        }
        canvas {
            display: block;
        }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
        }
        .hud-text {
            text-shadow: 2px 2px 0 #000;
        }
        #start-screen, #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 10;
            pointer-events: auto;
        }
        .btn {
            background: #e17055;
            border: none;
            padding: 15px 40px;
            font-size: 1.5rem;
            color: white;
            cursor: pointer;
            border-radius: 50px;
            margin-top: 20px;
            font-family: 'Russo One', sans-serif;
            transition: transform 0.1s;
            box-shadow: 0 4px 0 #d35400;
        }
        .btn:active {
            transform: translateY(4px);
            box-shadow: 0 0 0 #d35400;
        }
        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>

    <!-- Oyun Alanı -->
    <canvas id="gameCanvas"></canvas>

    <!-- UI Katmanı -->
    <div id="ui-layer">
        <div class="flex justify-between w-full max-w-4xl mx-auto">
            <div class="text-white text-2xl hud-text">SKOR: <span id="scoreEl">0</span></div>
            <div class="text-white text-2xl hud-text">KALAN TOP: <span id="ballsEl">10</span></div>
        </div>
        <div id="messageEl" class="text-center text-4xl text-yellow-400 hud-text font-bold opacity-0 transition-opacity duration-500">GOL!</div>
        <div class="text-white/50 text-sm text-center">Nişan al ve Tıkla!</div>
    </div>

    <!-- Başlangıç Ekranı -->
    <div id="start-screen">
        <h1 class="text-6xl text-yellow-400 mb-4" style="text-shadow: 4px 4px 0 #000;">SÜPER PENALTI</h1>
        <p class="text-xl text-gray-300">GitHub Sürümü</p>
        <button class="btn" onclick="startGame()">OYUNA BAŞLA</button>
    </div>

    <!-- Oyun Sonu Ekranı -->
    <div id="game-over-screen" class="hidden">
        <h1 class="text-5xl text-white mb-2">OYUN BİTTİ</h1>
        <p class="text-2xl text-yellow-400 mb-6">TOPLAM SKOR: <span id="finalScore">0</span></p>
        <button class="btn" onclick="resetGame()">TEKRAR OYNA</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // UI Elementleri
        const scoreEl = document.getElementById('scoreEl');
        const ballsEl = document.getElementById('ballsEl');
        const messageEl = document.getElementById('messageEl');
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const finalScoreEl = document.getElementById('finalScore');

        // Oyun Değişkenleri
        let gameState = 'MENU'; // MENU, PLAYING, GAMEOVER
        let score = 0;
        let ballsLeft = 10;
        let frameCount = 0;
        
        // Boyutlandırma
        let width, height;
        
        // Ses Context'i (Tarayıcı etkileşimi sonrası başlar)
        let audioCtx;

        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
        }

        function playSound(type) {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);

            if (type === 'kick') {
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(150, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(40, audioCtx.currentTime + 0.1);
                gain.gain.setValueAtTime(1, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.1);
            } else if (type === 'goal') {
                osc.type = 'square';
                osc.frequency.setValueAtTime(400, audioCtx.currentTime);
                osc.frequency.linearRampToValueAtTime(600, audioCtx.currentTime + 0.1);
                osc.frequency.linearRampToValueAtTime(400, audioCtx.currentTime + 0.2);
                gain.gain.setValueAtTime(0.5, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.6);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.6);
            } else if (type === 'miss') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(200, audioCtx.currentTime);
                osc.frequency.linearRampToValueAtTime(100, audioCtx.currentTime + 0.3);
                gain.gain.setValueAtTime(0.5, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.3);
            }
        }

        // --- OYUN OBJELERİ ---

        const goal = {
            x: 0, y: 0, w: 0, h: 0,
            draw: function() {
                // Kale Direkleri (Perspektif)
                const topWidth = this.w * 0.8;
                const bottomWidth = this.w;
                const topX = this.x + (this.w - topWidth) / 2;
                
                // File Arka Planı
                ctx.save();
                ctx.beginPath();
                ctx.moveTo(topX, this.y);
                ctx.lineTo(topX + topWidth, this.y);
                ctx.lineTo(this.x + this.w, this.y + this.h);
                ctx.lineTo(this.x, this.y + this.h);
                ctx.closePath();
                ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.fill();
                
                // File Desenleri
                ctx.strokeStyle = 'rgba(255,255,255,0.4)';
                ctx.lineWidth = 1;
                // Dikey
                for(let i=0; i<=10; i++) {
                    let t = i/10;
                    let tx = topX + topWidth*t;
                    let bx = this.x + this.w*t;
                    ctx.beginPath();
                    ctx.moveTo(tx, this.y);
                    ctx.lineTo(bx, this.y + this.h);
                    ctx.stroke();
                }
                // Yatay
                for(let i=0; i<=6; i++) {
                    let y = this.y + (this.h * (i/6));
                    // Basit yatay çizgiler
                    ctx.beginPath();
                    // Perspektif hesabı biraz karışık o yüzden düz çiziyoruz bu örnekte
                    ctx.moveTo(this.x, y); 
                    ctx.lineTo(this.x + this.w, y); 
                    ctx.stroke(); 
                }

                // Direkler
                ctx.strokeStyle = '#ecf0f1';
                ctx.lineWidth = 8;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                ctx.beginPath();
                // Üst Direk
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(this.x + this.w, this.y);
                // Sol Direk
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(this.x, this.y + this.h);
                // Sağ Direk
                ctx.moveTo(this.x + this.w, this.y);
                ctx.lineTo(this.x + this.w, this.y + this.h);
                ctx.stroke();
                
                // Gölge
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.beginPath();
                ctx.ellipse(this.x, this.y+this.h, 10, 5, 0, 0, Math.PI*2);
                ctx.ellipse(this.x+this.w, this.y+this.h, 10, 5, 0, 0, Math.PI*2);
                ctx.fill();

                ctx.restore();
            }
        };

        const keeper = {
            x: 0, y: 0, w: 60, h: 90,
            tx: 0, // Target X
            speed: 0,
            state: 'IDLE', // IDLE, JUMP
            animFrame: 0,
            color: '#e74c3c',
            
            update: function() {
                // Basit yapay zeka: Top yoksa gezin, top geliyorsa atla
                if (ball.shooting) {
                    // Topun hedefi kalenin içindeyse oraya git
                    if (ball.targetX > goal.x && ball.targetX < goal.x + goal.w) {
                        this.tx = ball.targetX - this.w/2;
                        // Tepki süresi gecikmesi
                        if(ball.z > 0.5) { 
                            this.speed = (this.tx - this.x) * 0.15;
                        } else {
                            this.speed = (this.tx - this.x) * 0.1;
                        }
                    }
                } else {
                    // Boşta sallanma (Sinüs dalgası)
                    this.tx = goal.x + (goal.w/2 - this.w/2) + Math.sin(frameCount * 0.05) * (goal.w * 0.3);
                    this.speed = (this.tx - this.x) * 0.1;
                }

                this.x += this.speed;

                // Sınırları koru
                if(this.x < goal.x) this.x = goal.x;
                if(this.x > goal.x + goal.w - this.w) this.x = goal.x + goal.w - this.w;
            },

            draw: function() {
                ctx.save();
                // Kaleci basit çizimi
                const cx = this.x + this.w/2;
                const cy = this.y + this.h/2;
                
                // Gölge
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.beginPath();
                ctx.ellipse(cx, this.y + this.h, this.w/2, 10, 0, 0, Math.PI*2);
                ctx.fill();

                // Gövde
                ctx.fillStyle = this.color;
                // Zıplama efekti
                let jumpY = (ball.shooting && Math.abs(this.speed) > 2) ? -10 : 0;
                
                // Forma
                ctx.fillRect(this.x, this.y + jumpY, this.w, this.h * 0.6);
                
                // Şort
                ctx.fillStyle = '#2c3e50';
                ctx.fillRect(this.x + 5, this.y + this.h * 0.6 + jumpY, this.w/2 - 5, this.h * 0.3);
                ctx.fillRect(this.x + this.w/2, this.y + this.h * 0.6 + jumpY, this.w/2 - 5, this.h * 0.3);

                // Kafa
                ctx.fillStyle = '#f1c40f'; // Ten rengi
                ctx.beginPath();
                ctx.arc(cx, this.y - 10 + jumpY, 15, 0, Math.PI*2);
                ctx.fill();

                // Kollar
                ctx.strokeStyle = '#f1c40f';
                ctx.lineWidth = 10;
                ctx.beginPath();
                // Sol kol
                ctx.moveTo(this.x, this.y + 10 + jumpY);
                if (ball.shooting) {
                    // Topa uzanma
                    ctx.lineTo(this.x - 15, this.y - 10 + jumpY);
                } else {
                    ctx.lineTo(this.x - 10, this.y + 40 + jumpY);
                }
                // Sağ kol
                ctx.moveTo(this.x + this.w, this.y + 10 + jumpY);
                if (ball.shooting) {
                    ctx.lineTo(this.x + this.w + 15, this.y - 10 + jumpY);
                } else {
                    ctx.lineTo(this.x + this.w + 10, this.y + 40 + jumpY);
                }
                ctx.stroke();

                ctx.restore();
            },
            
            getRect: function() {
                return {x: this.x, y: this.y, w: this.w, h: this.h};
            }
        };

        const ball = {
            x: 0, y: 0, z: 0, // Z: 0 (Bize yakın) -> 1 (Kalede)
            r: 20,
            vx: 0, vy: 0, vz: 0,
            shooting: false,
            result: null, // 'GOAL', 'SAVED', 'MISS'
            targetX: 0, targetY: 0,
            
            reset: function() {
                this.z = 0;
                this.r = 20; // Başlangıç boyutu
                this.x = width / 2;
                this.y = height - 100;
                this.vx = 0;
                this.vy = 0;
                this.vz = 0;
                this.shooting = false;
                this.result = null;
                // Kaleci konumunu sıfırlama, oyun aksın
            },

            shoot: function(tx, ty) {
                if (this.shooting) return;
                this.shooting = true;
                this.targetX = tx;
                this.targetY = ty;

                // Hedefe giden vektörü hesapla
                // Basit bir 3D hilesi: Y yukarı giderken Z artar (derinlik)
                const dx = tx - this.x;
                const dy = ty - this.y; // Genelde negatiftir (yukarı)
                
                this.vx = dx * 0.04; // Yatay hız
                // Y hızı aslında Z hızı gibi davranacak
                this.vz = 0.03; 
                this.vy = dy * 0.04; 

                playSound('kick');
            },

            update: function() {
                if (!this.shooting) return;

                this.x += this.vx;
                this.y += this.vy;
                this.z += this.vz;

                // Perspektif küçülmesi
                this.r = 20 * (1 - this.z * 0.6); 

                // Yerçekimi efekti (Yükselip düşme)
                this.vy += 0.5; 

                // Kaleye ulaştı mı? (Z yaklaşık 0.9 - 1.0 arası)
                if (this.z >= 0.8 && !this.result) {
                    this.checkCollision();
                }

                // Top çok uzağa giderse veya durursa reset
                if (this.z > 1.5 || this.y > height + 50) {
                   endRound();
                }
            },

            checkCollision: function() {
                // 1. Kaleci Kontrolü
                const k = keeper.getRect();
                // Topun merkezi kaleci karesinin içinde mi?
                if (this.x > k.x - 10 && this.x < k.x + k.w + 10 && 
                    this.y > k.y - 10 && this.y < k.y + k.h + 10) {
                    this.result = 'SAVED';
                    this.vx = -this.vx * 0.5; // Geri sekme
                    this.vz = -0.01;
                    this.vy = -5;
                    showMessage("KURTARDI!", "text-red-500");
                    playSound('miss');
                    return;
                }

                // 2. Kale Kontrolü
                // Kale çizgisine ulaştığında
                if (this.z >= 0.95) {
                    if (this.x > goal.x && this.x < goal.x + goal.w &&
                        this.y > goal.y && this.y < goal.y + goal.h) {
                        this.result = 'GOAL';
                        score++;
                        scoreEl.innerText = score;
                        // Fileye çarpınca dur
                        this.vx *= 0.1;
                        this.vy *= 0.1;
                        showMessage("GOL!!!", "text-yellow-400");
                        createConfetti(this.x, this.y);
                        playSound('goal');
                    } else {
                        this.result = 'MISS';
                        showMessage("DIŞARI!", "text-gray-400");
                        playSound('miss');
                    }
                }
            },

            draw: function() {
                ctx.save();
                
                // Gölge (Top havadaysa gölge aşağıda ve küçük kalır)
                let shadowScale = 1 - this.z;
                let shadowY = height - 100 + (this.z * 50); // Basit gölge mantığı
                
                if(this.z < 1) { // Sadece yerdeyken veya havada yakken
                    ctx.fillStyle = 'rgba(0,0,0,0.2)';
                    ctx.beginPath();
                    // Gölge X'i topun X'ini takip eder ama Y zeminde kalır
                    // Perspektif hilesi: Başlangıç Y noktasını referans alıyoruz
                    let groundY = (height - 100) - (this.y - (height - 100)) * 0.1; 
                    // Bu basit fizik modelinde gölgeyi tam oturtmak zor, hile yapalım:
                    // Topun şimdiki Y'si değil, izdüşümü lazım.
                    // Basitleştirme:
                    ctx.ellipse(this.x, this.y + this.r + 5 + (this.z * 100), this.r, this.r/2, 0, 0, Math.PI*2);
                    ctx.fill();
                }

                // Topun Kendisi
                ctx.translate(this.x, this.y);
                // Dönme efekti
                if(this.shooting) ctx.rotate(frameCount * 0.2);
                
                ctx.beginPath();
                ctx.arc(0, 0, Math.max(2, this.r), 0, Math.PI * 2);
                ctx.fillStyle = '#fff';
                ctx.fill();
                ctx.strokeStyle = '#000';
                ctx.lineWidth = Math.max(1, this.r/10);
                ctx.stroke();
                
                // Top Desenleri (Pentagonumsu)
                ctx.beginPath();
                ctx.arc(0, 0, Math.max(1, this.r * 0.6), 0, Math.PI * 2); // İç desen
                ctx.fillStyle = '#2d3436';
                ctx.globalAlpha = 0.2; // Biraz şeffaf detay
                ctx.fill();
                ctx.globalAlpha = 1;

                ctx.restore();
            }
        };

        // --- PARTİKÜL SİSTEMİ (KONFETİ) ---
        let particles = [];
        function createConfetti(x, y) {
            for(let i=0; i<30; i++) {
                particles.push({
                    x: x, y: y,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.5) * 10,
                    life: 1.0,
                    color: `hsl(${Math.random()*360}, 100%, 50%)`
                });
            }
        }
        function updateParticles() {
            for(let i=particles.length-1; i>=0; i--) {
                let p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.2; // Yerçekimi
                p.life -= 0.02;
                if(p.life <= 0) particles.splice(i, 1);
            }
        }
        function drawParticles() {
            for(let p of particles) {
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life;
                ctx.beginPath();
                ctx.arc(p.x, p.y, 4, 0, Math.PI*2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;
        }

        // --- OYUN DÖNGÜSÜ ---

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            
            // Sahne elemanlarını yeniden konumlandır
            if (!ball.shooting) {
                ball.x = width / 2;
                ball.y = height - 100;
            }
            
            // Kale boyutları
            goal.w = Math.min(400, width * 0.6);
            goal.h = 180;
            goal.x = (width - goal.w) / 2;
            goal.y = height * 0.25; // Ufuk çizgisi civarı
            
            keeper.y = goal.y + goal.h - keeper.h;
            if(!ball.shooting) keeper.x = (width - keeper.w)/2;
        }

        function update() {
            frameCount++;
            
            if (gameState === 'PLAYING') {
                keeper.update();
                ball.update();
                updateParticles();
            }
        }

        function draw() {
            // 1. Arka Plan (Çim ve Gökyüzü)
            // Gökyüzü
            let gradSky = ctx.createLinearGradient(0, 0, 0, height*0.3);
            gradSky.addColorStop(0, '#74b9ff');
            gradSky.addColorStop(1, '#dfe6e9');
            ctx.fillStyle = gradSky;
            ctx.fillRect(0, 0, width, height*0.3);

            // Çim
            let gradGrass = ctx.createLinearGradient(0, height*0.3, 0, height);
            gradGrass.addColorStop(0, '#27ae60');
            gradGrass.addColorStop(1, '#2ecc71');
            ctx.fillStyle = gradGrass;
            ctx.fillRect(0, height*0.3, width, height*0.7);

            // Ceza Sahası Çizgisi (Perspektif)
            ctx.strokeStyle = 'rgba(255,255,255,0.6)';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(0, height * 0.85); // Sol alt
            ctx.lineTo(goal.x, goal.y + goal.h); // Kale solu
            ctx.lineTo(goal.x + goal.w, goal.y + goal.h); // Kale sağı
            ctx.lineTo(width, height * 0.85); // Sağ alt
            ctx.stroke();

            // 2. Objeler
            goal.draw();
            keeper.draw();
            ball.draw();
            drawParticles();

            // Nişangah (Sadece şut atılmadıysa)
            if (gameState === 'PLAYING' && !ball.shooting && mousePos.y < ball.y) {
                ctx.strokeStyle = 'rgba(255, 255, 0, 0.5)';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(ball.x, ball.y);
                ctx.lineTo(mousePos.x, mousePos.y);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Hedef Nokta
                ctx.fillStyle = 'rgba(255, 0, 0, 0.7)';
                ctx.beginPath();
                ctx.arc(mousePos.x, mousePos.y, 10, 0, Math.PI*2);
                ctx.fill();
            }
        }

        function loop() {
            update();
            draw();
            requestAnimationFrame(loop);
        }

        // --- GİRİŞ VE KONTROL ---
        let mousePos = {x: 0, y: 0};

        function handleInput(x, y) {
            if (gameState !== 'PLAYING') return;
            
            mousePos.x = x;
            mousePos.y = y;
        }

        function handleClick() {
            if (gameState !== 'PLAYING') return;
            if (ball.shooting) return;

            // Şut çek
            ball.shoot(mousePos.x, mousePos.y);
        }

        // Mouse Events
        window.addEventListener('mousemove', e => handleInput(e.clientX, e.clientY));
        window.addEventListener('mousedown', handleClick);

        // Touch Events
        window.addEventListener('touchmove', e => {
            e.preventDefault();
            handleInput(e.touches[0].clientX, e.touches[0].clientY);
        }, {passive: false});
        
        window.addEventListener('touchstart', e => {
            handleInput(e.touches[0].clientX, e.touches[0].clientY);
            handleClick();
        });

        // --- OYUN YÖNETİMİ ---

        function startGame() {
            initAudio();
            startScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            gameState = 'PLAYING';
            score = 0;
            ballsLeft = 10;
            scoreEl.innerText = score;
            ballsEl.innerText = ballsLeft;
            ball.reset();
        }

        function endRound() {
            ballsLeft--;
            ballsEl.innerText = ballsLeft;
            
            if (ballsLeft <= 0) {
                gameOver();
            } else {
                ball.reset();
            }
        }

        function gameOver() {
            gameState = 'GAMEOVER';
            finalScoreEl.innerText = score;
            gameOverScreen.classList.remove('hidden');
        }

        function resetGame() {
            startGame();
        }

        function showMessage(text, colorClass) {
            messageEl.innerText = text;
            messageEl.className = `text-center text-5xl font-bold opacity-100 transition-opacity duration-500 ${colorClass} hud-text`;
            messageEl.style.transform = 'scale(1.5)';
            
            setTimeout(() => {
                messageEl.style.opacity = '0';
                messageEl.style.transform = 'scale(1)';
            }, 1000);
        }

        window.addEventListener('resize', resize);
        
        // Başlangıç
        resize();
        loop();

    </script>
</body>
</html>

